#+TITLE: init.el for Noah Hoffman
#+AUTHOR: Noah Hoffman

#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+STYLE: <link rel="stylesheet" type="text/css" href="./worg.css" />
#+BIND: org-export-html-postamble nil
#+PROPERTY: header-args:elisp :tangle init.el
#+PROPERTY: header-args:sh :eval no :exports code

In a fit of literate programming yak-shaving, I implemented my emacs
configuration as an org-mode file. I since realized that I could also
provide complete-ish instructions for getting started with Emacs in a
single location (I have the pleasure of introducing Emacs to people
who may be new to both programming and Emacs in my job).

- The source for this page is available at https://github.com/nhoffman/.emacs.d
- The html-exported version of this page is hosted at http://nhoffman.github.io/.emacs.d

#+TOC: headlines 1

* Initial setup

You can install this configuration by either cloning it directly
from my repository, of by forking on GitHub and installing yours
(obviously you will want to do the latter if you want to modify the
configuration):

#+BEGIN_SRC sh
cd ~
git clone https://github.com/nhoffman/.emacs.d.git
#+END_SRC

After cloning the repository into your home directory, just a bit of
setup is required before first use.

** set up a shell environment

This configuration provides some shell functions and aliases (tested
with bash and zsh) that are useful for using Emacs from the shell. In
particular, if you are on a mac and have installed [[http://emacsformacosx.com/][Emacs for OS X]] or
compiled the Cocoa version, Emacs will be installed to
=/Applications/Emacs.app/Contents/MacOS/Emacs= and =emacsclient= is
found in
=/Applications/Emacs.app/Contents/MacOS/bin/emacsclient=. These are
aliased to =emacs= and =emacsclient=, respectively.

In addition, there are some functions that simplify running and using
Emacs in server mode:

- edaemon :: launch the Emacs server daemon, removing any locked desktop files.
- ec :: attach to the Emacs server in GUI mode (=emacsclient -c=) in the background.
- enw :: attach to the Emacs server in terminal mode in place (=emacsclient -nw=).
- e :: open a file in an already open window (=emacsclient -n=).

Rather than copying the functions defined in =init.bash= elsewhere,
I'd recommend sourcing it instead. For example, just place the
following in your =~/.bash_login= or =~/.zshrc= or [[http://shreevatsa.wordpress.com/2008/03/30/zshbash-startup-files-loading-order-bashrc-zshrc-etc/][whatever]] (depending
on your shell):

#+BEGIN_SRC sh :eval no
if [[ -f ~/.emacs.d/init.bash ]]; then
    source ~/.emacs.d/init.bash
fi
#+END_SRC

** option as Meta on a Mac

I use Emacs from a variety of terminal types on my machines running OS
X:

- the Cocoa version when working locally
- X11 when working remotely over a fast connection
- a terminal application when working remotely over a slow connection

I have done my best to configure all three to provide an experience
that's as comparable as possible. Here are some configuration
suggestions to use the option key as Meta (as opposed to Esc, which is
just insane).

*** Cocoa

I just download it from http://emacsformacosx.com/ - as far as I can
tell, option is used as Meta by default.

*** X11

I use [[http://xquartz.macosforge.org/downloads/SL/XQuartz-2.7.7.dmg][XQuartz]]

Create the file ~/.Xmodmap as follows to use option as Meta in X11
(you'll need to quit X11 for the changes to take effect):

#+BEGIN_SRC sh
cat > ~/.Xmodmap <<EOF
clear Mod1
clear Mod2
keycode 63 = Mode_switch
keycode 66 = Meta_L
add Mod1 = Meta_L
add Mod2 = Mode_switch
EOF
#+END_SRC

[[http://tylerkieft.com/archives/2006/10/05/redefine-the-x11-meta-key-in-mac-os-x/][This post]] has more information on configuring X11.

*** Terminal

I prefer [[http://iterm2.com/][iTerm2]] over Terminal.app

Head over to Preferences --> Profiles --> Keys and do these things:

- select "Left/right option key acts as": +Esc (to use option as Meta)
- + --> Keyboard shortcut "OPT+<left arrow>": Send Escape sequence "b"
- + --> Keyboard shortcut "OPT+<right arrow>": Send Escape sequence "f"

The last two items cause option plus the right and left arrows to
perform the same actions as =M-f= (=forward-word=) and =M-b=
(=backward-word=) in both Emacs and in contexts that support default
readline key bindings (which is [[https://coderwall.com/p/usc8qg][just about everywhere]]).

** install packages from ELPA

The only required step to use this configuration is to install
packages from EPLA, the Emacs Lisp Package Archive. See the "ELPA"
section below for a list of packages installed by this configuration
(defined in =my-package-list=). First, launch Emacs; I'd recommend
launching without emacs-desktop, for example =emacs -nw
--no-desktop=. Install specified packages with =M-x
install-packages= (see the *Elpa* section below). At this point
it's usually a good idea to quit and relaunch Emacs.

** create virtualenv

The packages used here (particularly =elpy=) require some python
bits. The easiest way to provide them is to install them in a
virtualenv. There's a script to do this - just run:

#+BEGIN_SRC sh :eval no
bin/venv.sh
#+END_SRC

This will create =~/.emacs.d/emacs-env=. If =scons= isn't installed,
this will add that, too. In this case, you'll need to activate the
virtualenv (=source emacs-env/bin/activate=) to use the version of
=scons= installed there. I'll explain later why having =scons= is
useful.

** initialize org-export submodule (optional)

If you want to compile =init.org= to html using the provided build
script, you'll need to initialize and update the git [[http://git-scm.com/book/en/Git-Tools-Submodules][submodule]]
containing the =org-export= project
(https://github.com/nhoffman/org-export). This only needs to be done
once after checking out this repository:

#+BEGIN_SRC sh
git submodule update --init
#+END_SRC

To update the =org-export= repository, first try

#+BEGIN_SRC sh
git submodule update
#+END_SRC

This will update to whatever commit is associated with the project, eg

#+BEGIN_SRC sh :eval yes :results output :exports both
git submodule status
#+END_SRC

If this doesn't do anything, try

#+BEGIN_SRC sh
(cd org-export && git checkout org-export && git pull origin master)
#+END_SRC

If there were any changes, you'll need to make a commit in
=.emacs.d=. Ugh, submodules.

* Maintaining and using this file

All changes to the configuration should be made within code blocks in
this file. After any changes, this file must be "tangled" to produce
=init.el=. The elisp version of the configuration is committed to the
git repository (even though it is a derived file) to make it easier to
get started when first cloning the repository onto a new system. An
html-exported version of this file is also published to GitHub
pages. All of this is automated using =scons=. The default target is
=init.el=, so after changing this file, you can compile =init.el= by
simply typing

: scons

If you'd rather tangle the file interactively, use =C-c C-v t=
(=org-babel-tangle=).

Additional targets include =scons html= to compile =html/index.html=
and =scons publish= to update the =gh-pages= branch of the repo on
GitHub.

To help keep track of functions I've defined, I like to make aliases
that prepend the value of `my-alias-prefix'. Here's a function to help
with making aliases.

#+BEGIN_SRC elisp
(defvar my-alias-prefix "my/")

(defun make-alias (fun &optional prefix)
  "Create an alias for function `fun' by prepending the value of
  `my-alias-prefix' to the symbol name. Use `prefix' to provide
  an alternative prefix string. Example:

  (defun bar () (message \"I am bar\"))
  (make-alias 'bar \"foo-\")
  (foo-bar) => \"I am bar\""

  (interactive)
  (defalias
    (intern (concat (or prefix my-alias-prefix) (symbol-name fun)))
    fun))
#+END_SRC

If you want to reload the init file after a change, here's a function to do so:

#+BEGIN_SRC elisp
(defun init-load ()
  "Load ~/.emacs.d/init.el"
  (interactive)
  (load "~/.emacs.d/init.el"))
(global-set-key (kbd "M-C-i") 'init-load)
(make-alias 'init-load)
#+END_SRC

* Startup

This will only work with emacs 24.x

#+BEGIN_SRC elisp :tangle init.el
(unless (= emacs-major-version 24)
  (error "Emacs version 24 is required"))
#+END_SRC

#+BEGIN_SRC elisp
(message "loading ~/.emacs.d/init.el")
#+END_SRC

* ELPA

Set up and initialize ELPA package manager.

Some useful ELPA variables and functions:

| =M-x package-list-packages= | open list of packages                                                 |
| =package-activated-list=    | variable containing list of the names of currently activated packages |
| =package-install=           | install a package                                                     |
| =package-installed-p=       | return true if package is installed                                   |

Add some extra package repositories. The default value of package-archives is
=(("gnu" . "http://elpa.gnu.org/packages/"))=

#+BEGIN_SRC elisp
(when (>= emacs-major-version 24)
  (require 'package)
  (package-initialize)
  ;; Original Emacs Lisp Package Archive
  (add-to-list 'package-archives
       '("elpa" . "http://tromey.com/elpa/") t)
  ;; User-contributed repository
  ;; Marmalade is for packages that cannot be uploaded to the official ELPA repository.
  (add-to-list 'package-archives
       '("marmalade" . "http://marmalade-repo.org/packages/") t)
  (add-to-list 'package-archives
       '("melpa" . "http://melpa.milkbox.net/packages/") t)
  (add-to-list 'package-archives
       '("org" . "http://orgmode.org/elpa/") t)
  (add-to-list 'package-archives
       '("elpy" . "http://jorgenschaefer.github.io/packages/") t)
  )
#+END_SRC

I could not find an obvious way to define a list of packages to
automatically install, so here are some functions to do so. Execute
=M-x install-packages= to install any missing packages. Note that
when installing org-mode from elpa for the first time, you must be
sure that the builtin version of org-mode has not been loaded since
emacs was first started.

#+BEGIN_SRC elisp
(defun package-installed-not-builtin-p (package &optional min-version)
  "Return true if PACKAGE, of MIN-VERSION or newer, is installed,
  ignoring built in packages.  MIN-VERSION should be a version list."
  (let ((pkg-desc (assq package package-alist)))
    (if pkg-desc
        (version-list-<= min-version (package-desc-vers (cdr pkg-desc))))))

(defun package-install-list (pkg-list)
  ;; Install each package in pkg-list if necessary.
  (mapcar
   (lambda (pkg)
     (unless (package-installed-not-builtin-p pkg)
       (package-install pkg)))
   pkg-list)
  (message "done installing packages"))

(defvar my-package-list
  '(ace-jump-mode
    ace-jump-buffer
    auctex
    edit-server
    elpy
    ess
    ;; flymake-cursor
    ;; flycheck
    ;; flycheck-color-mode-line
    gist
    git-timemachine
    htmlize
    ;; jedi
    jinja2-mode
    magit
    markdown-mode
    moinmoin-mode
    org
    ;; python-pylint
    ;; projectile
    rainbow-delimiters
    smex
    yaml-mode
    yas-jit))

(defun install-packages ()
  ;; Install packages listed in global 'my-package-list'
  (interactive)
  (package-list-packages)
  (package-install-list my-package-list))
(make-alias 'install-packages)
#+END_SRC

* smex

See https://github.com/nonsequitur/smex - Ido extension for previously
used extended commands. Installed using elpa.

#+BEGIN_SRC elisp
(if (package-installed-p 'smex)
    (progn
      (global-set-key (kbd "M-x") 'smex)
      (global-set-key (kbd "C-c M-x") 'smex-major-mode-commands)
      ;; This is your old M-x.
      (global-set-key (kbd "C-x M-x") 'execute-extended-command)))
#+END_SRC

* Various aliases and key bindings

** Function keys.

It's kind of surprising that the function keys aren't
either defined or bound to more commonly used functions by
default.

|-----+--------------------------------------+---------------+----------------------|
| key | default binding                      | also bound to | my binding           |
|-----+--------------------------------------+---------------+----------------------|
| f1  | view-order-manuals                   | C-h           |                      |
| f2  | 2C-command                           | C-x 6         | fix-frame            |
| f3  | kmacro-start-macro-or-insert-counter |               |                      |
| f4  | kmacro-end-or-call-macro             |               |                      |
| f5  |                                      |               | call-last-kbd-macro  |
| f6  |                                      |               | lineum-mode          |
| f7  |                                      |               | visual-line-mode     |
| f8  |                                      |               | ns-toggle-fullscreen |
| f9  |                                      |               |                      |
| f10 | menu-bar-open                        |               |                      |
| f11 | (OS X: Show Desktop)                 |               |                      |
| f12 | (OS X: Show Dashboard)               |               |                      |

#+BEGIN_SRC elisp
(global-set-key (kbd "<f6>") 'linum-mode)
(global-set-key (kbd "<f7>") 'visual-line-mode)
(global-set-key (kbd "<f8>") 'ns-toggle-fullscreen)
#+END_SRC

Various other custom key bindings.

#+BEGIN_SRC elisp
(global-set-key (kbd "C-c r") 'replace-string)
#+END_SRC

#+BEGIN_SRC elisp
(defalias 'dtw 'delete-trailing-whitespace)
#+END_SRC

* General appearance

Enable debugging

#+BEGIN_SRC elisp
;; (setq debug-on-error t)
;; (setq debug-on-signal t)

#+END_SRC

#+BEGIN_SRC elisp
(setq column-number-mode t)
(setq inhibit-splash-screen t)
(setq require-final-newline t)
(setq make-backup-files nil)
(setq initial-scratch-message nil)
(setq suggest-key-bindings 4)
(show-paren-mode 1)
#+END_SRC

Date and time in status bar. See http://efod.se/writings/linuxbook/html/date-and-time.html

#+BEGIN_SRC elisp
(setq display-time-day-and-date t
      display-time-24hr-format t)
(display-time)
#+END_SRC

File path in title bar. See http://stackoverflow.com/questions/3669511/the-function-to-show-current-files-full-path-in-mini-buffer

#+BEGIN_SRC elisp
(setq frame-title-format
      (list (format "%s %%S: %%j " (system-name))
            '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))
#+END_SRC

automatically refresh buffers from disk (default is every 5 sec)
see http://www.cs.cmu.edu/cgi-bin/info2www?(emacs)Reverting

#+BEGIN_SRC elisp
(global-auto-revert-mode 1)
#+END_SRC

Add paths to 'exec-path' so that Emacs can find executables not
otherwise defined in PATH.

#+BEGIN_SRC elisp
(add-to-list 'exec-path "~/.emacs.d/bin")
#+END_SRC

Also update the =$PATH= environment variable inherited by shell
commands run from within Emacs.

#+BEGIN_SRC elisp
(defun prepend-path (path)
  "Add `path' to the beginning of $PATH unless already present."
  (interactive)
  (unless (string-match path (getenv "PATH"))
    (setenv "PATH" (concat path ":" (getenv "PATH")))))

(prepend-path "~/.emacs.d/bin")
#+END_SRC

* Environment
** update load path

#+BEGIN_SRC elisp
(add-to-list 'load-path "~/.emacs.d/")
#+END_SRC

** update SSH_AUTH_SOCK

If you 1) forward ssh authentication (ie, ssh -A), 2) have a
long-running emacs --daemon and 3) set an expiration on your ssh
authentication, then you will lose the ability to perform ssh public
key authentication once the authentication expires. So actions like
pushing/pulling using magit will fail. This can be addressed by
updating the value of the SSH_AUTH_SOCK environment variable. Here's a
function to fix this.

#+BEGIN_SRC elisp
(defun ssh-refresh ()
  "Reset the environment variable SSH_AUTH_SOCK"
  (interactive)
  (let (ssh-auth-sock-old (getenv "SSH_AUTH_SOCK"))
    (setenv "SSH_AUTH_SOCK"
            (car (split-string
                  (shell-command-to-string
                   (if (eq system-type 'darwin)
 "ls -t $(find /tmp/* -user $USER -name Listeners 2> /dev/null)"
 "ls -t $(find /tmp/ssh-* -user $USER -name 'agent.*' 2> /dev/null)"
 )))))
    (message
     (format "SSH_AUTH_SOCK %s --> %s"
             ssh-auth-sock-old (getenv "SSH_AUTH_SOCK")))))
(make-alias 'ssh-refresh)
#+END_SRC
** exec-path-from-shell

Initialize the PATH environment variable when starting up the Emacs
app from the finder. Found this tip here: https://plus.google.com/104330705025733851532/posts/K6YPSVEB9Nx

Commenting out for now, but seems promising....

#+BEGIN_SRC elisp
  ;; (when (memq window-system '(mac ns))
  ;;   (exec-path-from-shell-initialize))
#+END_SRC

* Exiting and saving

Require prompt before exit on C-x C-c
- http://www.dotemacs.de/dotfiles/KilianAFoth.emacs.html

#+BEGIN_SRC elisp
(global-set-key [(control x) (control c)]
		(function
		 (lambda () (interactive)
		   (cond ((y-or-n-p "Quit? (save-buffers-kill-terminal) ")
			  (save-buffers-kill-terminal))))))
#+END_SRC

Delete trailing whitespace before save.

#+BEGIN_SRC elisp
(setq delete-trailing-lines nil)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

* Platform and display-specific settings

Detect platform and window system and set up fonts and other
system-specific settings accordingly. It may be necessary to run =M-x
fix-frame= after opening a new frame attached to a running emacs
server process.

#+BEGIN_SRC elisp
(defun set-default-font-verbosely (font-name)
  (interactive)
  (message (format "** setting default font to %s" font-name))
  (condition-case nil
      (set-default-font font-name)
    (error (message (format "** Error: could not set to font %s" font-name)))))

(defun fix-frame (&optional frame)
  "Apply platform-specific settings."
  (interactive)
  (menu-bar-mode -1)    ;; hide menu bar
  (tool-bar-mode -1)    ;; hide tool bar
  (scroll-bar-mode -1)  ;; hide scroll bar
  (cond ((string= "ns" window-system) ;; cocoa
         (progn
           (message (format "** running %s windowing system" window-system))
           ;; key bindings for mac - see
           ;; http://stuff-things.net/2009/01/06/emacs-on-the-mac/
           ;; http://osx.iusethis.com/app/carbonemacspackage
           (set-keyboard-coding-system 'mac-roman)
           (setq mac-option-modifier 'meta)
           (setq mac-command-key-is-meta nil)
           (set-default-font-verbosely "Bitstream Vera Sans Mono-14")))
        ((string= "x" window-system)
         (progn
           (message (format "** running %s windowing system" window-system))
           (set-default-font-verbosely "Liberation Mono-10")
           ;; M-w or C-w copies to system clipboard
           ;; see http://www.gnu.org/software/emacs/elisp/html_node/Window-System-Selections.html
           (setq x-select-enable-clipboard t)))
        (t
         (message "** running in terminal mode"))))
(global-set-key (kbd "<f2>") 'fix-frame)
(make-alias 'fix-frame)
(fix-frame)
#+END_SRC

* Scrolling

See http://www.emacswiki.org/emacs/SmoothScrolling

#+BEGIN_SRC elisp
(setq mouse-wheel-scroll-amount '(3 ((shift) . 3))) ;; number of lines at a time
(setq mouse-wheel-progressive-speed nil)            ;; don't accelerate scrolling
(setq mouse-wheel-follow-mosue 't)                  ;; scroll window under mouse
(setq scroll-step 1)                                ;; keyboard scroll one line at a time
(setq scroll-conservatively 1)                      ;; scroll by one line to follow cursor off screen
(setq scroll-margin 2)                              ;; Start scrolling when 2 lines from top/bottom
#+END_SRC

* Cursor movement and appearance.

** ace-jump-mode

A quick cursor location minor mode for emacs. I picked =M-'= as the
key combo for activation. Installed from ELPA.

#+BEGIN_SRC elisp
(define-key global-map (kbd "M-'") 'ace-jump-mode)
#+END_SRC

** Prettier cursor

#+BEGIN_SRC elisp
(set-cursor-color "red")
(blink-cursor-mode 1)
#+END_SRC

* Keyboard macros

See http://www.emacswiki.org/emacs/KeyboardMacros
note that default bindings for macros are:

| C-x ( | start defining a keyboard macro  |
| C-x ) | stop defining the keyboard macro |
| C-x e | execute the keyboard macro       |

Some additional keyboard macro bindings.

#+BEGIN_SRC elisp
(global-set-key (kbd "<f5>") 'call-last-kbd-macro)
#+END_SRC

* emacs desktop

References:
- http://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html
- http://www.emacswiki.org/emacs/DeskTop

Save desktop periodically instead of just on exit, but not if emacs is
started with =--no-desktop=. Note that "--no-desktop" is deleted from
`command-line-args' when desktop is activated, so we have to check
before that.

#+BEGIN_SRC elisp
(defun desktop-save-no-p ()
  "Save desktop without prompting (replaces `desktop-save-in-desktop-dir')"
  (interactive)
  ;; (message (format "Saving desktop in %s" desktop-dirname))
  (desktop-save desktop-dirname))

(if (member "--no-desktop" command-line-args)
    (message "** Desktop auto-save is disabled")
  (progn
    (require 'desktop)
    (desktop-save-mode 1)
    (message "** Desktop auto-save is enabled")
    (add-hook 'auto-save-hook 'desktop-save-no-p)))
#+END_SRC

* Move lines up and down with arrow keys

See http://stackoverflow.com/questions/2423834/move-line-region-up-and-down-in-emacs

Move line up

#+BEGIN_SRC elisp
(defun move-line-up ()
  (interactive)
  (transpose-lines 1)
  (previous-line 2))
(global-set-key (kbd "M-<up>") 'move-line-up)
#+END_SRC

Move line down.

#+BEGIN_SRC elisp
(defun move-line-down ()
  (interactive)
  (next-line 1)
  (transpose-lines 1)
  (previous-line 1))
(global-set-key (kbd "M-<down>") 'move-line-down)
#+END_SRC

* Buffers and windows
** Use =iswitchb=

#+BEGIN_SRC elisp
(iswitchb-mode 1)
#+END_SRC

** Use =electric-buffer-list=

Replace default =list-buffers= with =electric-buffer-list= for buffer
selection.

#+BEGIN_SRC elisp
(global-set-key (kbd "C-x C-b") 'electric-buffer-list)
#+END_SRC

** Switch windows with arrow keys

Note that other-window is bound by default to =C-x o=

#+BEGIN_SRC elisp
(defun back-window ()
  (interactive)
  (other-window -1))
(global-set-key (kbd "C-<right>") 'other-window)
(global-set-key (kbd "C-<left>") 'back-window)
#+END_SRC

** Transpose buffers

- see http://www.emacswiki.org/emacs/SwitchingBuffers
- note that original code used function 'plusp', which seems not to be defined in recent versions of emacs

#+BEGIN_SRC elisp
(defun transpose-buffers (arg)
  "Transpose the buffers shown in two windows."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
            (next-win (window-buffer (funcall selector))))
        (set-window-buffer (selected-window) next-win)
        (set-window-buffer (funcall selector) this-win)
        (select-window (funcall selector)))
      ;; (setq arg (if (plusp arg) (1- arg) (1+ arg)))
      (setq arg (if (>= arg 0) (1- arg) (1+ arg)))
      )))
(global-set-key (kbd "C-x 4") 'transpose-buffers)
#+END_SRC

** Switch buffers between frames

Also from http://www.emacswiki.org/emacs/SwitchingBuffers

#+BEGIN_SRC elisp
(defun switch-buffers-between-frames ()
  "switch-buffers-between-frames switches the buffers between the two last frames"
  (interactive)
  (let ((this-frame-buffer nil)
	(other-frame-buffer nil))
    (setq this-frame-buffer (car (frame-parameter nil 'buffer-list)))
    (other-frame 1)
    (setq other-frame-buffer (car (frame-parameter nil 'buffer-list)))
    (switch-to-buffer this-frame-buffer)
    (other-frame 1)
    (switch-to-buffer other-frame-buffer)))
(global-set-key (kbd "C-x 5") 'switch-buffers-between-frames)
#+END_SRC

** Toggle frame split

Toggles between a horizontal and vertical split (two frames only).

Copied from http://www.emacswiki.org/emacs/ToggleWindowSplit (submitted by Wilfred).

#+BEGIN_SRC elisp
  (defun toggle-frame-split ()
    "If the frame is split vertically, split it horizontally or vice versa.
  Assumes that the frame is only split into two."
    (interactive)
    (unless (= (length (window-list)) 2) (error "Can only toggle a frame split in two"))
    (let ((split-vertically-p (window-combined-p)))
      (delete-window) ; closes current window
      (if split-vertically-p
          (split-window-horizontally)
        (split-window-vertically)) ; gives us a split with the other window twice
      (switch-to-buffer nil))) ; restore the original window in this part of the frame

  (global-set-key (kbd "C-x 6") 'toggle-frame-split)
#+END_SRC

** Force horizontal splits

#+BEGIN_SRC elisp
(setq split-height-threshold nil)
#+END_SRC

** ace-jump-buffer

Quickly jump to another buffer by selecting a letter from a pop-up
menu (bind to =M-"=).

#+BEGIN_SRC elisp
(define-key global-map (kbd "M-\"") 'ace-jump-buffer)
#+END_SRC

* spelling

Use aspell instead of ispell

#+BEGIN_SRC elisp
(setq-default ispell-program-name "aspell")
(setq ispell-dictionary "en")
#+END_SRC

Enable on-the-fly spell-check

#+BEGIN_SRC elisp
(autoload 'flyspell-mode "flyspell" "On-the-fly spelling checker." t)
(setq flyspell-issue-welcome-flag nil) ;; fix error message
#+END_SRC

* pine/alpine

http://snarfed.org/space/emacs%20font-lock%20faces%20for%20composing%20email

#+BEGIN_SRC elisp
  (add-hook 'find-file-hooks
            '(lambda ()
               (if (equal "pico." (substring (buffer-name (current-buffer)) 0 5))
                   ;; (message "** running hook for pine/alpine")
                   (mail-mode))))
#+END_SRC

* LaTeX

Install AuxTeX from elpa.

* ESS

Installed using elpa, but seems to need =require= to be called
explicitly.

#+BEGIN_SRC elisp
(condition-case nil
    (require 'ess-site)
  (error (message "** could not load ESS")))
#+END_SRC

Hooks

#+BEGIN_SRC elisp
(add-hook 'ess-mode-hook
	  '(lambda()
	     (message "Loading ess-mode hooks")
	     ;; leave my underscore key alone!
	     (setq ess-S-assign "_")
	     ;; (ess-toggle-underscore nil)
	     ;; set ESS indentation style
	     ;; choose from GNU, BSD, K&R, CLB, and C++
	     (ess-set-style 'GNU 'quiet)
	     (flyspell-mode)
	     )
	  )
#+END_SRC

* org-mode

org-mode hooks

#+BEGIN_SRC elisp
(add-hook 'org-mode-hook
          '(lambda ()
             (message "Loading org-mode hooks")
             ;; (font-lock-mode)
             (setq org-confirm-babel-evaluate nil)
             (setq org-src-fontify-natively t)
             (setq org-edit-src-content-indentation 0)
             (define-key org-mode-map (kbd "M-<right>") 'forward-word)
             (define-key org-mode-map (kbd "M-<left>") 'backward-word)
             ;; provides key mapping for the above; replaces default
             ;; key bindings for org-promote/demote-subtree
             (define-key org-mode-map (kbd "M-S-<right>") 'org-do-demote)
             (define-key org-mode-map (kbd "M-S-<left>") 'org-do-promote)
             (visual-line-mode)
             ;; org-babel
             (org-babel-do-load-languages
              'org-babel-load-languages
              '((R . t)
                (latex . t)
                (python . t)
                (sh . t)
                (sql . t)
                (sqlite . t)
                ))
             ;; (defun org-with-silent-modifications(&rest args)
             ;;   "Replaces function causing error on org-export"
             ;;   (message "Using fake 'org-with-silent-modifications'"))
             (defadvice org-todo-list (after org-todo-list-bottom ())
               "Move to bottom of page after entering org-todo-list"
               (progn (end-of-buffer) (recenter-top-bottom)))
             (ad-activate 'org-todo-list)
             ))

(setq org-agenda-files (list "~/Dropbox/notes/index.org"))
(push '("\\.org\\'" . org-mode) auto-mode-alist)
(push '("\\.org\\.txt\\'" . org-mode) auto-mode-alist)
#+END_SRC

Custom key bindings

#+BEGIN_SRC elisp
(global-set-key (kbd "C-c a") 'org-agenda)
#+END_SRC

** org-mode utilities

#+BEGIN_SRC elisp
(defun insert-date ()
  ;; Insert today's timestamp in format "<%Y-%m-%d %a>"
  (interactive)
  (insert (format-time-string "<%Y-%m-%d %a>")))
(global-set-key (kbd "C-c d") 'insert-date)
(make-alias 'insert-date)
#+END_SRC

#+BEGIN_SRC elisp
(defun org-add-entry (filename time-format)
  ;; Add an entry to an org-file with today's timestamp.
  (interactive "FFile: ")
  (find-file filename)
  (end-of-buffer)
  (delete-blank-lines)
  ;;(insert "\n* ")
  (insert (format-time-string time-format))
  (beginning-of-line)
  (forward-char 2))
#+END_SRC

Add a new entry to main notes file.

#+BEGIN_SRC elisp
(global-set-key
 (kbd "C-x C-n") (lambda () (interactive)
		   (org-add-entry "~/Dropbox/notes/index.org"
				  "\n* <%Y-%m-%d %a>")))
#+END_SRC

Add a new entry to my journal.

Add a new entry to main notes file.

#+BEGIN_SRC elisp
(global-set-key
 (kbd "C-x C-j") (lambda () (interactive)
                   (org-add-entry "~/Dropbox/journal/journal.org"
                                  "\n* %A, %B %d, %Y")))
#+END_SRC

* markdown-mode

Installed using elpa.

#+BEGIN_SRC elisp
(push '("\\.md" . markdown-mode) auto-mode-alist)
#+END_SRC

* chrome "edit with emacs"

'edit-server' is initialized by elpa, but we need to start the server.

#+BEGIN_SRC elisp
(condition-case nil
    (edit-server-start)
  (error (message "** could not start edit-server (chrome edit with emacs)")))
#+END_SRC

* Python

- http://jesselegg.com/archives/2010/02/25/emacs-python-programmers-part-1/

** hooks

#+BEGIN_SRC elisp
(add-hook 'python-mode-hook
          '(lambda ()
             (message "Loading python-mode hooks")
             (setq indent-tabs-mode nil)
             (setq tab-width 4)
             (setq py-indent-offset tab-width)
             (setq py-smart-indentation t)
             (define-key python-mode-map "\C-m" 'newline-and-indent)
             (setq python-check-command "~/.emacs.d/bin/pychecker")
             ))
#+END_SRC

File name mappings

#+BEGIN_SRC elisp
(push '("SConstruct" . python-mode) auto-mode-alist)
(push '("SConscript" . python-mode) auto-mode-alist)
(push '("*.cgi" . python-mode) auto-mode-alist)
#+END_SRC

Default 'untabify converts a tab to equivalent number of spaces before
deleting a single character.

#+BEGIN_SRC elisp
(setq backward-delete-char-untabify-method "all")
#+END_SRC

Make indentation more compliant with pep8 (see http://stackoverflow.com/revisions/5361478/2)

#+BEGIN_SRC elisp :tangle inactive.el
  (defadvice python-calculate-indentation (around outdent-closing-brackets)
    "Handle lines beginning with a closing bracket and indent them so that
    they line up with the line containing the corresponding opening bracket."
    (save-excursion
      (beginning-of-line)
      (let ((syntax (syntax-ppss)))
        (if (and (not (eq 'string (syntax-ppss-context syntax)))
                 (python-continuation-line-p)
                 (cadr syntax)
                 (skip-syntax-forward "-")
                 (looking-at "\\s)"))
            (progn
              (forward-char 1)
              (ignore-errors (backward-sexp))
              (setq ad-return-value (current-indentation)))
          ad-do-it))))

  (ad-activate 'python-calculate-indentation)
#+END_SRC

** python-pylint

Installed using ELPA.

Invoke with =M-x python-pylint RET=

** autopep8

Apply =autopep8= (https://github.com/hhatto/autopep8) to the current
buffer. Reference: *Mastering Emacs*:
http://www.masteringemacs.org/articles/2011/10/19/executing-shell-commands-emacs/

#+BEGIN_SRC elisp
  (defun p8 ()
    "Apply autopep8 to the current region or buffer"
    (interactive)
    (unless (region-active-p)
      (mark-whole-buffer))
    (shell-command-on-region
     (region-beginning) (region-end) ;; beginning and end of region or buffer
     "autopep8 -"                    ;; command and parameters
     (current-buffer)                ;; output buffer
     t                               ;; replace?
     "*autopep8 errors*"             ;; name of the error buffer
     t))                             ;; show error buffer?
#+END_SRC

Instead of simply replacing the current buffer, use ediff to compare
it to the output of autopep8.

#+BEGIN_SRC elisp
  (defun p8-and-ediff ()
    "Compare the current buffer to the output of autopep8 using ediff"
    (interactive)
    (let ((p8-output
           (get-buffer-create (format "* %s autopep8 *" (buffer-name)))))
      (shell-command-on-region
       (point-min) (point-max)    ;; beginning and end of buffer
       "autopep8 -"               ;; command and parameters
       p8-output                  ;; output buffer
       nil                        ;; replace?
       "*autopep8 errors*"        ;; name of the error buffer
       t)                         ;; show error buffer?
      (ediff-buffers (current-buffer) p8-output)
      ))
#+END_SRC

** flycheck

An alternative to =flymake=. Install =flycheck= via elpa. For python,
requires flask8 or pyflakes; flake8 is used preferentially if
installed.

See https://github.com/arcthur/.emacs.d/blob/master/extensions/init-flycheck.el

#+BEGIN_SRC elisp :tangle inactive.el
(add-hook 'flycheck-mode-hook
          '(lambda ()
             (setq flycheck-highlighting-mode 'lines)
             (flycheck-color-mode-line-mode)
             )
          )
#+END_SRC

** flymake: check code dynamically

Flymake can be used to check python code dynamically, for example
using pyflakes and pep8. I found (and slightly modified) instructions
here:
https://astropy.readthedocs.org/en/v0.1/development/codeguide_emacs.html

Requirements:
- pep8 (via pip)
- pyflakes (via pip)
- flymake-cursor (via elpa)
- "~/.emacs.d/bin/pychecker", a script that will execute pyflakes and
  pep8 (note that "~/.emacs.d/bin" has been added to "exec-path"
  above):

#+BEGIN_SRC sh :exports both :results output
cat ~/.emacs.d/bin/pychecker
#+END_SRC

Error codes are listed here: http://pep8.readthedocs.org/en/latest/intro.html#error-codes

And some configuration:
#+BEGIN_SRC elisp :tangle inactive.el
(require 'flymake)

;; TODO - first check if flymake-cursor is installed
(condition-case nil
    (load-library "flymake-cursor") ;; install from elpa
      (error (message "** flymake-cursor not installed")))

;; 'pychecker' script above installed in ~/.emacs.d/bin
(setq pycodechecker "pychecker")

(when (load "flymake" t)
  (defun flymake-pycodecheck-init ()
    (let* ((temp-file (flymake-init-create-temp-buffer-copy
                       'flymake-create-temp-inplace))
           (local-file (file-relative-name
                        temp-file
                        (file-name-directory buffer-file-name))))
      (list pycodechecker (list local-file))))
  (add-to-list 'flymake-allowed-file-name-masks
               '("\\.py\\'" flymake-pycodecheck-init))
  (add-to-list 'flymake-allowed-file-name-masks
               '("SCons" flymake-pycodecheck-init)))
;; (add-hook 'python-mode-hook 'flymake-mode)
#+END_SRC

** elpy

- Installation :: https://github.com/jorgenschaefer/elpy/wiki/Installation
- note that =python-check-command= (set in python hooks above) defines the program used by =elpy-check=

#+BEGIN_SRC elisp
(condition-case nil
    (elpy-enable) ;; install from elpa
  (error (message "** could not enable elpy")))
#+END_SRC

As of version 1.5.0, the elpy python package is distributed with the
elpa elisp package, but other dependencies (such as jedi) still need
to be available. Assuming elpy dependencies are installed in
~/.emacs.d/emacs-env

#+BEGIN_SRC elisp
(defvar venv-default "~/.emacs.d/emacs-env")
(defun activate-venv-default ()
  (interactive)
  (pyvenv-activate venv-default)
  (elpy-rpc-restart))
(make-alias 'activate-venv-default)
#+END_SRC

Also add executables in the default virtualenv to =$PATH=

#+BEGIN_SRC elisp
(prepend-path "~/.emacs.d/emacs-env/bin")
#+END_SRC

Here's a function that tries to activate a virtualenv in the current
project.

#+BEGIN_SRC elisp
(defun activate-venv ()
  "Activate a virtualenv if one can be found in the current
project; otherwise activate the virtualenv defined in
`venv-default'. Also restarts the elpy rpc process."
  (interactive)
  (let ((venv nil)
        (find-pattern "find %s -path '*bin/activate' -maxdepth 4")
        (msg ""))

    (if (elpy-project-root)
        (setq venv
              (replace-regexp-in-string
               "/bin/activate[ \t\n]*" ""
               (shell-command-to-string
                (format find-pattern (elpy-project-root))))))

    (if (< (length venv) 1)
        (progn
          (setq venv venv-default)
          (setq msg "(cound not find a virtualenv here) ")))

    (if (y-or-n-p (format "%sActivate %s?" msg venv))
        (progn
          (pyvenv-activate venv)
          (elpy-rpc-restart)
          (message "Using %s" pyvenv-virtual-env)))))
(make-alias 'activate-venv)
#+END_SRC

This function installs python dependencies to the current virtualenv
from within Emacs.

#+BEGIN_SRC elisp
(defun elpy-install-requirements ()
  "Install `elpy' and `jedi' to the current virtualenv. The
version of the `elpy' python package is forced to match the
version of the elisp package, upgrading or downgrading as
necessary."
  (interactive)
  (unless pyvenv-virtual-env
    (error "Error: no virtualenv is active"))
  (let ((dest "*elpy-install-requirements-output*")
        (install-cmd (format "%s/bin/pip install --force '%%s'" pyvenv-virtual-env))
        ;; (deps `(,(format "elpy==%s" elpy-version) "jedi")))
        (deps '("jedi" "pyflakes" "pep8")))
    (generate-new-buffer dest)
    (mapcar
     #'(lambda (pkg)
         (message (format install-cmd pkg))
         (call-process-shell-command (format install-cmd pkg) nil dest)) deps)
    (call-process-shell-command
     (format "%s/bin/pip freeze" pyvenv-virtual-env) nil dest)
    (switch-to-buffer dest)
    ))
(make-alias 'elpy-install-requirements)
#+END_SRC

I use =C= + arrows to move between windows, and =M= + arrows to move
by word. These are in muscle memory at this point, and elpy can't have
them.

#+BEGIN_SRC elisp
(add-hook 'elpy-mode-hook
'(lambda ()
   (define-key elpy-mode-map (kbd "C-<right>") nil)
   (define-key elpy-mode-map (kbd "C-<left>") nil)
   (define-key elpy-mode-map (kbd "M-<right>") nil)
   (define-key elpy-mode-map (kbd "M-<left>") nil)
   (define-key elpy-mode-map (kbd "M-<right>") nil)
   (define-key elpy-mode-map (kbd "M-C-]") 'elpy-nav-move-iblock-right)
   (define-key elpy-mode-map (kbd "M-C-[") 'elpy-nav-move-iblock-left)
   (setq elpy-rpc-backend "jedi")
   (add-to-list 'elpy-project-ignored-directories "src")
   (add-to-list 'elpy-project-ignored-directories "*-env")
))
#+END_SRC

** jedi

Python auto-completion with Jedi (http://tkf.github.io/emacs-jedi/)

Install =jedi.el= via elpa.

Install python requirements:

: pip install -r $(ls .emacs.d/elpa/jedi-*/requirements.txt)

#+BEGIN_SRC elisp :tangle inactive.el
(add-hook 'python-mode-hook 'jedi:setup)
(setq jedi:setup-keys t)
(setq jedi:complete-on-dot t)
#+END_SRC

* scons

I should really start using a snippet package, but for now:

#+BEGIN_SRC elisp
(defun scons-insert-command ()
  (interactive)
  (insert "output, = env.Command(
    target=,
    source=,
    action=('')
)"))
(make-alias 'scons-insert-command)
#+END_SRC

* text-mode

#+BEGIN_SRC elisp
(add-hook 'text-mode-hook
	  '(lambda ()
	     ;; (longlines-mode)
	     (flyspell-mode)
	     )
	  )
#+END_SRC

* rst-mode

#+BEGIN_SRC elisp
(add-hook 'rst-mode-hook
	  '(lambda ()
	     (message "Loading rst-mode hooks")
	     (flyspell-mode)
	     (define-key rst-mode-map (kbd "C-c C-a") 'rst-adjust)
	     )
	  )
#+END_SRC

* tramp

- http://www.gnu.org/software/tramp/

#+BEGIN_SRC elisp
(condition-case nil
    (require 'tramp)
  (setq tramp-default-method "scp")
  (error (message "** could not load tramp")))
#+END_SRC

* ibuffer

- http://emacs-fu.blogspot.com/2010/02/dealing-with-many-buffers-ibuffer.html

#+BEGIN_SRC elisp
(require 'ibuffer)
(global-set-key (kbd "C-x C-g") 'ibuffer)
(global-set-key (kbd "C-x M-g") 'ibuffer-switch-to-saved-filter-groups)
(setq ibuffer-show-empty-filter-groups nil)
#+END_SRC

Function to load config file. Load on starup.

#+BEGIN_SRC elisp
(defvar my-ibuffer-config-file "~/.emacs.d/ibuffer-config.el")

(defun ibuffer-load-config ()
  ;; load the ibuffer config file
  (interactive)
  (condition-case nil
      (progn
	(message (format "** loading ibuffer config in %s" my-ibuffer-config-file))
	(load my-ibuffer-config-file)
	)
    (error (message (format "** could not load %s" my-ibuffer-config-file))))
  )

(ibuffer-load-config)
#+END_SRC

Show/hide all filter groups

#+BEGIN_SRC elisp
(defun ibuffer-show-all-filter-groups ()
  "Show all filter groups"
  (interactive)
  (setq ibuffer-hidden-filter-groups nil)
  (ibuffer-update nil t))

(defun ibuffer-hide-all-filter-groups ()
  "Hide all filter groups"
  (interactive)
  (setq ibuffer-hidden-filter-groups
	(delete-dups
	 (append ibuffer-hidden-filter-groups
		 (mapcar 'car (ibuffer-generate-filter-groups
			       (ibuffer-current-state-list)
			       (not ibuffer-show-empty-filter-groups)
			       t)))))
  (ibuffer-update nil t))
#+END_SRC

#+BEGIN_SRC elisp
(defun ibuffer-reload ()
  ;; kill ibuffer, reload the config file, and return to ibuffer
  (interactive)
  (ibuffer)
  (kill-buffer)
  (ibuffer-load-config)
  (ibuffer)
  )
#+END_SRC

From http://www.emacswiki.org/emacs/IbufferMode

#+BEGIN_SRC elisp
(defun my-ibuffer-sort-hook ()
  ;; add another sorting method for ibuffer (allow the grouping of
  ;; filenames and dired buffers
  (define-ibuffer-sorter filename-or-dired
    "Sort the buffers by their pathname."
    (:description "filenames plus dired")
    (string-lessp
     (with-current-buffer (car a)
       (or buffer-file-name
	   (if (eq major-mode 'dired-mode)
	       (expand-file-name dired-directory))
	   ;; so that all non pathnames are at the end
	   "~"))
     (with-current-buffer (car b)
       (or buffer-file-name
	   (if (eq major-mode 'dired-mode)
	       (expand-file-name dired-directory))
	   ;; so that all non pathnames are at the end
	   "~"))))
  (define-key ibuffer-mode-map (kbd "s p")     'ibuffer-do-sort-by-filename-or-dired)
  )
#+END_SRC

From http://curiousprogrammer.wordpress.com/2009/04/02/ibuffer/

#+BEGIN_SRC elisp
(defun ibuffer-ediff-marked-buffers ()
  "Compare two marked buffers using ediff"
  (interactive)
  (let* ((marked-buffers (ibuffer-get-marked-buffers))
         (len (length marked-buffers)))
    (unless (= 2 len)
      (error (format "%s buffer%s been marked (needs to be 2)"
                     len (if (= len 1) " has" "s have"))))
    (ediff-buffers (car marked-buffers) (cadr marked-buffers))))
#+END_SRC

Hooks

#+BEGIN_SRC elisp
(add-hook 'ibuffer-mode-hook
          '(lambda ()
             (ibuffer-auto-mode 1) ;; minor mode that keeps the buffer list up to date
             (ibuffer-switch-to-saved-filter-groups "default")
             (define-key ibuffer-mode-map (kbd "a") 'ibuffer-show-all-filter-groups)
             (define-key ibuffer-mode-map (kbd "z") 'ibuffer-hide-all-filter-groups)
             (define-key ibuffer-mode-map (kbd "e") 'ibuffer-ediff-marked-buffers)
             (my-ibuffer-sort-hook)
             ;; don't accidentally print; see http://irreal.org/blog/?p=2013
             (defadvice ibuffer-do-print (before print-buffer-query activate)
               (unless (y-or-n-p "Print buffer? ")
                 (error "Cancelled")))
             )
          )
#+END_SRC

* uniquify

- http://www.emacswiki.org/emacs/uniquify

#+BEGIN_SRC elisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'post-forward)
#+END_SRC

* projectile

Project-centric file and directory navigation - see
https://github.com/bbatsov/projectile

Installed using ELPA.

Basic key bindings (see the url above for a complete list).

| keybinding | description                                       |
| C-c p C-h  | Help with projectile key bindings                 |
| C-c p f    | Display a list of all files in the project.       |
| C-c p d    | Display a list of all directories in the project. |

#+BEGIN_SRC elisp :tangle inactive.el
(if (package-installed-p 'projectile)
    (projectile-global-mode))
#+END_SRC

* ido-mode

- http://www.masteringemacs.org/articles/2010/10/10/introduction-to-ido-mode/

#+BEGIN_SRC elisp
(setq ido-enable-flex-matching t)
(setq ido-everywhere t)
(setq ido-use-virtual-buffers t)
(ido-mode 1)
#+END_SRC

use recentf with ido - see http://wikemacs.org/wiki/Recentf

#+BEGIN_SRC elisp
(recentf-mode 1)
(defun ido-choose-from-recentf ()
  "Use ido to select a recently visited file from the `recentf-list'"
  (interactive)
  (find-file (ido-completing-read "Open file: " recentf-list nil t)))
(global-set-key (kbd "C-c f") 'ido-choose-from-recentf)
#+END_SRC

* git/magit

#+BEGIN_SRC elisp
(require 'vc-git)
#+END_SRC

Magit is installed via ELPA.

#+BEGIN_SRC elisp
(global-set-key (kbd "C-c m") 'magit-status)
#+END_SRC

* sql support

- see http://atomized.org/2008/10/enhancing-emacs%E2%80%99-sql-mode/

Use sqlite3

#+BEGIN_SRC elisp
(setq sql-sqlite-program "sqlite3")
#+END_SRC

Preset connections

#+BEGIN_SRC elisp
(setq sql-connection-alist
      '((some-server
         (sql-product 'mysql)
         (sql-server "1.2.3.4")
         (sql-user "me")
         (sql-password "mypassword")
         (sql-database "thedb")
         (sql-port 3307))))

(defun sql-connect-preset (name)
  "Connect to a predefined SQL connection listed in `sql-connection-alist'"
  (eval `(let ,(cdr (assoc name sql-connection-alist))
    (flet ((sql-get-login (&rest what)))
      (sql-product-interactive sql-product)))))

(defun sql-mastermu ()
  (interactive)
  (sql-connect-preset 'mastermu))

;; buffer naming
(defun sql-make-smart-buffer-name ()
  "Return a string that can be used to rename a SQLi buffer.
This is used to set `sql-alternate-buffer-name' within
`sql-interactive-mode'."
  (or (and (boundp 'sql-name) sql-name)
      (concat (if (not(string= "" sql-server))
                  (concat
                   (or (and (string-match "[0-9.]+" sql-server) sql-server)
                       (car (split-string sql-server "\\.")))
                   "/"))
              sql-database)))

(add-hook 'sql-interactive-mode-hook
          (lambda ()
            (setq sql-alternate-buffer-name (sql-make-smart-buffer-name))
            (sql-rename-buffer)))
#+END_SRC

* gpg

- http://www.emacswiki.org/emacs/EasyPG

#+BEGIN_SRC elisp
(require 'epa-file)
(setenv "GPG_AGENT_INFO" nil) ;; suppress graphical passphrase prompt
#+END_SRC
* Outline minor mode

The default key bindings for outline-minor-mode start with 'C-c @ C-',
which is... awkward. Use alternative bindings courtesy of Sue D. Nymme
via emacswiki (http://emacswiki.org/emacs/OutlineMinorMode).

#+BEGIN_SRC elisp
  ;; Outline-minor-mode key map
  (define-prefix-command 'cm-map nil "Outline-")
  ;; HIDE
  (define-key cm-map "q" 'hide-sublevels)    ; Hide everything but the top-level headings
  (define-key cm-map "t" 'hide-body)         ; Hide everything but headings (all body lines)
  (define-key cm-map "o" 'hide-other)        ; Hide other branches
  (define-key cm-map "c" 'hide-entry)        ; Hide this entry's body
  (define-key cm-map "l" 'hide-leaves)       ; Hide body lines in this entry and sub-entries
  (define-key cm-map "d" 'hide-subtree)      ; Hide everything in this entry and sub-entries
  ;; SHOW
  (define-key cm-map "a" 'show-all)          ; Show (expand) everything
  (define-key cm-map "e" 'show-entry)        ; Show this heading's body
  (define-key cm-map "i" 'show-children)     ; Show this heading's immediate child sub-headings
  (define-key cm-map "k" 'show-branches)     ; Show all sub-headings under this heading
  (define-key cm-map "s" 'show-subtree)      ; Show (expand) everything in this heading & below
  ;; MOVE
  (define-key cm-map "u" 'outline-up-heading)                ; Up
  (define-key cm-map "n" 'outline-next-visible-heading)      ; Next
  (define-key cm-map "p" 'outline-previous-visible-heading)  ; Previous
  (define-key cm-map "f" 'outline-forward-same-level)        ; Forward - same level
  (define-key cm-map "b" 'outline-backward-same-level)       ; Backward - same level
  ;; commands are prefixed with C-c o
  (global-set-key (kbd "C-c o") cm-map)

#+END_SRC

* Misc utilities
** copy-buffer-file-name

#+BEGIN_SRC elisp
(defun copy-buffer-file-name ()
  "Add `buffer-file-name' to `kill-ring'"
  (interactive)
  (kill-new buffer-file-name t))
(make-alias 'copy-buffer-file-name)
#+END_SRC

** copy-and-comment

#+BEGIN_SRC elisp
(defun copy-and-comment ()
  "Comment active region and paste uncommented text on the
following line."
  (interactive)
  (kill-new
   (buffer-substring
    (region-beginning)
    (region-end)))
  (comment-region (region-beginning)
                  (region-end))
  (goto-char (region-end))
  (delete-blank-lines)
  (newline 2)
  (yank))

(global-set-key (kbd "M-C-;") 'copy-and-comment)
#+END_SRC

** unfill-paragraph

from http://defindit.com/readme_files/emacs_hints_tricks.html

#+BEGIN_SRC elisp
(defun unfill-paragraph ()
  (interactive)
  (let ((fill-column (point-max)))
  (fill-paragraph nil)))
(global-set-key (kbd "M-C-q") 'unfill-paragraph)
(make-alias 'unfill-paragraph)
#+END_SRC

** occur-region-or-word-at-point

A convenient way to search the current buffer with =occur=.

Note that =occur= can be executed using "M-s o"

#+BEGIN_SRC elisp
(defun occur-region-or-word-at-point ()
  "Run `occur' using the active region or word at point"
  (interactive)
  (let ((occur-string (if (region-active-p)
                          (buffer-substring (region-beginning) (region-end))
                        (thing-at-point 'word))))
    (unless occur-string
      (error "No active region or word at point"))
    (occur occur-string)
    ))
(global-set-key (kbd "M-s r") 'occur-region-or-word-at-point)
#+END_SRC

* elisp-format

Written by Andy Stewart and available on emacswiki: http://www.emacswiki.org/emacs/elisp-format.el

#+BEGIN_SRC elisp
(condition-case nil
    (require 'elisp-format)
  (error (message "** could not load elisp-format")))
#+END_SRC

* emacsclient

Buffers opened from command line don't create new frame

#+BEGIN_SRC elisp
(setq ns-pop-up-frames nil)
#+END_SRC

* lockstep

Lockstep is a package for pair programming in Emacs. See https://github.com/tjim/lockstep

Installation:

#+BEGIN_SRC sh :eval no
wget -N https://github.com/tjim/lockstep/archive/master.zip
unzip master.zip lockstep-master/lockstep.el
mv lockstep-master/lockstep.el .
rm -r lockstep-master master.zip
#+END_SRC

#+BEGIN_SRC elisp
(require 'lockstep)
#+END_SRC

To use, attach emacsclient to a running emacs server and evaluate =M-x lockstep=.
After this, a second user can do the same.

* enable commands

#+BEGIN_SRC elisp
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+END_SRC
* custom-set-variables

Emacs modifies this statement if you use the interactive "customize"
function, so don't do that.

#+BEGIN_SRC elisp
(custom-set-variables
  '(safe-local-variable-values (quote ((toggle-read-only . t)))))
#+END_SRC

* License
#+BEGIN_SRC elisp
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
#+END_SRC





